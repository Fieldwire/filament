// Simple unlit material that uses the colors associated with each vertex.
//
// This source material must be compiled to a binary material using the matc tool.
// The command used to compile this material is:
// matc -p mobile -a opengl -o app/src/main/assets/baked_color.filamat app/src/materials/baked_color.mat
//
// See build.gradle for an example of how to compile materials automatically
// Please refer to the documentation for more information about matc and the materials system.

material {
    name : baked_color,

    // Lists the required vertex attributes
    // Here we only need a color (RGBA)
    parameters : [
        {
            type : float2,
            name : res
        },
        {
            type : float4,
            name : clipPlane
        }
    ],

    // This material disables all lighting
    shadingModel : unlit,
}

fragment {

    void material(inout MaterialInputs material) {
        // You must always call the prepareMaterial() function
        prepareMaterial(material);

        // We set the material's color to the color interpolated from
        // the model's vertices
        // material.baseColor.rgba = materialParams.baseColor;

        // vec2 fragCoordNormalized = gl_FragCoord.xy / vec2(1080.0, 2125.0); // Assuming screen resolution of 640x480
        // if (fragCoordNormalized.y > materialParams.clipPlane) {
        //    discard;
        // }


        // float2 ndc = gl_FragCoord.xy / materialParams.resolution;

        // Calculate the angle in radians
        // float angle_radians = radians(materialParams.clipPlaneA);

        // Calculate the direction vector of the clipping plane
        // vec2 plane_direction = vec2(cos(angle_radians), sin(angle_radians));

        // Calculate the position vector of the fragment relative to the origin
        // vec2 fragment_position = ndc; // Assuming the origin is at the center of the screen

        // Calculate the dot product of the fragment position vector and the plane direction vector
        // float dot_product = dot(fragment_position, plane_direction);

        // Compare the dot product with zero to determine the side of the plane
        // if (dot_product > 0.5) {
            // Fragment is beyond the clipping plane, discard it
            // discard;
        // }


            // float angle_radians = radians(materialParams.clipPlaneA);

            // Calculate the slope of the clipping plane based on the angle
            // float slope = tan(angle_radians);

            // Calculate the y-coordinate of the clipping plane at the fragment's x-coordinate
            // float clipping_plane_y = slope * gl_FragCoord.x;

            // Compare the fragment's y-coordinate with the clipping plane
            // if (gl_FragCoord.y > clipping_plane_y) {
                // Fragment is beyond the clipping plane, discard it
               // discard;
            // }

            vec2 fragCoordNormalized = gl_FragCoord.xy / vec2(materialParams.res.x, materialParams.res.y);
            vec4 position = vec4(fragCoordNormalized.x, fragCoordNormalized.y, gl_FragCoord.z, 1.0);
            float dotP = dot(position, materialParams.clipPlane);

            if (dotP < 0.0) {
               discard;
            }
    }
}
